<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Home - XPaF</title>
  <link rel="stylesheet" href="xpaf.css">
</head>
<body>
<div id="content">
<h1 id="title">XPath-based Parsing Framework (XPaF)</h1>

<h2>Description</h2>

<p>XPath-based Parsing Framework (XPaF) is a simple, fast, <a href="https://github.com/google/xpaf">open-source</a> parsing framework that makes it easy to extract relations (subject-predicate-object triples) from HTML and XML documents.</p>

<p>For a quick example, see below. When you're ready for more, check out the <a href="tutorial.html">tutorial</a> or the <a href="faq.html">FAQ</a>.</p>

<h2>Installation</h2>

<p>Unix installation instructions are available <a href="https://github.com/google/xpaf/blob/master/README.md">here</a>.</p>

<h2>Quick example</h2>

<p>Consider the following HTML snippet:</p>

<pre class="code-block">
&lt;table&gt;
  &lt;tr&gt;
    &lt;td class="name"&gt;Aaron&lt;/td&gt;
    &lt;td class="occ"&gt;Engineer&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="name"&gt;Jennifer&lt;/td&gt;
    &lt;td class="occ"&gt;Archeologist&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>

<p>To extract name-occupation pairs from such tables, we'd write the following XPaF parser:</p>

<pre class="code-block">
parser_name: "my_parser"
relation_tmpls {
  subject: "//td[@class='name']"
  predicate: "occupation"
  object: "//td[@class='occ']"

  subject_cardinality: MANY
  object_cardinality: MANY
}
</pre>

<p>To run our parser, we'd write the following C++ code:</p>

<pre class="code-block">
XpafParserDefs parser_defs;
ReadXpafParserDefs("/path/to/my_parser.xpd", &amp;parser_defs);
ParseOptions parse_options;
const XpafParserMaster master(parser_defs, parse_options);
ParsedDocument output;
master.ParseDocument(doc, &amp;output);
</pre>

<p>For the HTML snippet and parser above, XPaF would produce the following output, encoded as a <a href="https://github.com/google/xpaf/blob/master/src/parsed_document.proto"><span class="code-inline">ParsedDocument</span></a> protocol buffer object:</p>

<pre class="code-block">
parser_name: "my_parser"
relations {
  subject: "Aaron"
  predicate: "occupation"
  object: "Engineer"
}
relations {
  subject: "Jennifer"
  predicate: "occupation"
  object: "Archeologist"
}
</pre>

<p>For a more detailed example, check out the <a href="tutorial.html">tutorial</a>.</p>

<p>The full parser specification language can be found <a href="https://github.com/google/xpaf/blob/master/src/xpaf_parser_def.proto">here</a> (start with <span class="code-inline">XPafParserDef</span>).</p>

<h2>Chrome extension</h2>

<p>The <a href="https://chrome.google.com/webstore/detail/hgimnogjllphhhkhlmebbmlgjoejdpjl">XPath Helper Chrome extension</a> makes it easy to extract, edit, and evaluate XPath queries on any webpage. It's very helpful for writing XPaF parsers.</p>

<p>The source code for XPath Helper is available <a href="https://github.com/google/xpaf/tree/master/chrome">here</a>.</p>

</div>
<div id="footer"><em>Adam Sadovsky</em></div>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="prettify.js"></script>
</body>
</html>
